函数式编程的一大特性就是：可以把函数当成变量来使用，比如将函数赋值给其他变量、把函数作为参数传递给其他函数、函数的返回值也可以是一个函数等等。

# 高阶函数

# 内建高阶函数

# 匿名函数

# 闭包

# 装饰器

# functiontool
## partial
partial 函数的功能就是：把一个函数的某些参数给固定住，返回一个新的函数。

## wraper
```
from functools import wraps,update_wrapper
def log(level="low"):
    def deco(func):
        @wraps(func)
        def wrapper(*args,**kwargs):
            ''' I am wrapper function'''
            print "log was in..."
            if level == "low":
                print "detailes was needed"
            return func(*args,**kwargs)
        #wrapper.__name__ = func.__name__
        #update_wrapper(wrapper, func, ('__name__','__doc__'), ('__dict__',))
        return wrapper
    return deco

@log()
def myFunc():
    '''I am myFunc...'''
    print "myFunc was called"

print myFunc.__name__
myFunc()
```

# 装饰器使用技巧
## 定义带参数的装饰器
```
from inspect import signature

def typeassert(*ty_args, **ty_kargs):
    def decorator(func):
        # func -> a,b 
        # d = {'a': int, 'b': str}
        sig = signature(func)
        btypes = sig.bind_partial(*ty_args, **ty_kargs).arguments
        print(btypes)
        def wrapper(*args, **kargs):
            # arg in d, instance(arg, d[arg])
            for name, obj in sig.bind(*args, **kargs).arguments.items():
                if name in btypes:
                    if not isinstance(obj, btypes[name]):
                        raise TypeError('"%s" must be "%s"' % (name, btypes[name]))
            return func(*args, **kargs)
        return wrapper
    return decorator

@typeassert(int, str, list)
def f(a, b, c):
    print(a, b, c)

f(1, 'abc', [1,2,3])
f(1, 2, [1,2,3])

```

## 实现属性可修改的装饰器
```
from functools import wraps

import time
import logging

def warn(timeout):
    timeout = [timeout]
    def decorator(func):
        def wrapper(*args, **kargs):
            start = time.time()
            res = func(*args, **kargs)
            used = time.time() - start
            if used > timeout[0]:
                msg = '"%s": %s > %s' % (func.__name__, used, timeout[0])
                logging.warn(msg)
            return res
        def setTimeout(k):
            #nonlocal timeout
            timeout[0] = k
        wrapper.setTimeout = setTimeout
        return wrapper
    return decorator

from random import randint
@warn(1.5)
def test():
    print('In test')
    while randint(0, 1):
        time.sleep(0.5)

for _ in range(30):
    test()

test.setTimeout(1)
for _ in range(30):
    test()
```






